<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />



<title>Introduction to glmnetUtils</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0A%7D%0Apre%20%7B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>



<div id="header">
<h1 class="title">Introduction to glmnetUtils</h1>
</div>


<p>The <a href="https://github.com/hong-revo/glmnetUtils">glmnetUtils package</a> provides a collection of tools to streamline the process of fitting elastic net models with <a href="https://cran.r-project.org/package=glmnet">glmnet</a>. I wrote the package after a couple of projects where I found myself writing the same boilerplate code to convert a data frame into a predictor matrix and a response vector. In addition to providing a formula interface, it also features a function <code>cvAlpha.glmnet</code> to do crossvalidation for both <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\lambda\)</span>, as well as some utility functions.</p>
<div id="the-formula-interface" class="section level2">
<h2>The formula interface</h2>
<p>The interface that glmnetUtils provides is very much the same as for most modelling functions in R. To fit a model, you provide a formula and data frame. You can also provide any arguments that glmnet will accept. Here are some simple examples for different types of data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># least squares regression</span>
(mtcarsMod &lt;-<span class="st"> </span><span class="kw">glmnet</span>(mpg ~<span class="st"> </span>cyl +<span class="st"> </span>disp +<span class="st"> </span>hp, <span class="dt">data=</span>mtcars))</code></pre></div>
<pre><code>## Call:
## glmnet.formula(formula = mpg ~ cyl + disp + hp, data = mtcars)
## 
## Model fitting options:
##     Sparse model matrix: FALSE
##     Use model.frame: FALSE
##     Alpha: 1
##     Lambda summary:
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
## 0.03326 0.11690 0.41000 1.02800 1.44100 5.05500</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># multinomial logistic regression with specified elastic net alpha parameter</span>
(irisMod &lt;-<span class="st"> </span><span class="kw">glmnet</span>(Species ~<span class="st"> </span>., <span class="dt">data=</span>iris, <span class="dt">family=</span><span class="st">&quot;multinomial&quot;</span>, <span class="dt">alpha=</span><span class="fl">0.5</span>))</code></pre></div>
<pre><code>## Call:
## glmnet.formula(formula = Species ~ ., data = iris, alpha = 0.5, 
##     family = &quot;multinomial&quot;)
## 
## Model fitting options:
##     Sparse model matrix: FALSE
##     Use model.frame: FALSE
##     Alpha: 0.5
##     Lambda summary:
##      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
## 0.0000435 0.0004353 0.0043550 0.0489600 0.0435400 0.4350000</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Poisson regression with an offset</span>
(InsMod &lt;-<span class="st"> </span><span class="kw">glmnet</span>(Claims ~<span class="st"> </span>District +<span class="st"> </span>Group +<span class="st"> </span>Age, <span class="dt">data=</span>MASS::Insurance,
                  <span class="dt">family=</span><span class="st">&quot;poisson&quot;</span>, <span class="dt">offset=</span><span class="kw">log</span>(Holders)))</code></pre></div>
<pre><code>## Call:
## glmnet.formula(formula = Claims ~ District + Group + Age, data = MASS::Insurance, 
##     family = &quot;poisson&quot;, offset = log(Holders))
## 
## Model fitting options:
##     Sparse model matrix: FALSE
##     Use model.frame: FALSE
##     Alpha: 1
##     Lambda summary:
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
## 0.02877 0.11610 0.46880 1.40500 1.89300 7.64100</code></pre>
<p>Under the hood, glmnetUtils creates a model matrix and response vector, and passes them to the glmnet package to do the actual model fitting. A simple <code>print</code> method is also provided, to show the main model details at a glance. I’ll describe shortly what the “sparse model matrix” and “use model.frame” options do.</p>
<p>Predicting from a model works as you’d expect: just pass a data frame containing the new observations to the <code>predict</code> method. You can also specify any arguments that <code>predict.glmnet</code> accepts.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># least squares regression: get predictions for lambda=1</span>
<span class="kw">predict</span>(mtcarsMod, <span class="dt">newdata=</span>mtcars, <span class="dt">s=</span><span class="dv">1</span>)

<span class="co"># multinomial logistic regression: get predicted class</span>
<span class="kw">predict</span>(irisMod, <span class="dt">newdata=</span>iris, <span class="dt">type=</span><span class="st">&quot;class&quot;</span>)

<span class="co"># Poisson regression: need to specify offset</span>
<span class="kw">predict</span>(InsMod, <span class="dt">newdata=</span>MASS::Insurance, <span class="dt">offset=</span><span class="kw">log</span>(Holders))</code></pre></div>
<p>If you want, you can still use the original model matrix-plus-response syntax:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mtcarsX &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(mtcars[<span class="kw">c</span>(<span class="st">&quot;cyl&quot;</span>, <span class="st">&quot;disp&quot;</span>, <span class="st">&quot;hp&quot;</span>)])
mtcarsY &lt;-<span class="st"> </span>mtcars$mpg
mtcarsMod2 &lt;-<span class="st"> </span><span class="kw">glmnet</span>(mtcarsX, mtcarsY)

<span class="kw">summary</span>(<span class="kw">as.numeric</span>(<span class="kw">predict</span>(mtcarsMod, mtcars) -<span class="st"> </span>
<span class="st">                   </span><span class="kw">predict</span>(mtcarsMod2, mtcarsX)))</code></pre></div>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##       0       0       0       0       0       0</code></pre>
<p>This shows that the resulting models are identical, in terms of the predictions they make and the regularisation parameters used.</p>
</div>
<div id="generating-the-model-matrix" class="section level2">
<h2>Generating the model matrix</h2>
<p>There are two ways in which glmnetUtils can generate a model matrix out of a formula and data frame. The first is to use the standard R machinery comprising <code>model.frame</code> and <code>model.matrix</code>; and the second is to build the matrix one variable at a time.</p>
<div id="using-model.frame" class="section level3">
<h3>Using <code>model.frame</code></h3>
<p>This is the simpler option, and the one that is most compatible with other R modelling functions. The <code>model.frame</code> function takes a formula and data frame and returns a <em>model frame</em>: a data frame with special information attached that lets R make sense of the terms in the formula. For example, if a formula includes an interaction term, the model frame will specify which columns in the data relate to the interaction, and how they should be treated. Similarly, if the formula includes expressions like <code>exp(x)</code> or <code>I(x^2)</code> on the RHS, <code>model.frame</code> will evaluate these expressions and include them in the output.</p>
<p>The major disadvantage of using <code>model.frame</code> is that it generates a <code>terms</code> object, which encodes how variables and interactions are organised. One of the attributes of this object is a matrix with one row per variable, and one column per main effect and interaction. At minimum, this is (approximately) a <span class="math inline">\(p \times p\)</span> square matrix where <span class="math inline">\(p\)</span> is the number of main effects in the model. For wide datasets with <span class="math inline">\(p &gt; 10000\)</span>, this matrix can approach or exceed a gigabyte in size. Even if there is enough memory to store such an object, generating the model matrix can be very slow.</p>
<p>Another issue with the standard R approach is the treatment of factors. Normally, model.matrix will turn an <span class="math inline">\(N\)</span>-level factor into an indicator matrix with <span class="math inline">\(N-1\)</span> columns, with one column being dropped. This is necessary for unregularised models as fit with <code>lm</code> and <code>glm</code>, since the full set of <span class="math inline">\(N\)</span> columns is linearly dependent. With the usual <a href="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/contrasts.html">treatment contrasts</a>, the interpretation is that the dropped column represents a baseline level, while the coefficients for the other columns represent the difference in the response relative to the baseline.</p>
<p>This may not be appropriate for a regularised model as fit with glmnet. The regularisation procedure shrinks the coefficients towards zero, which forces the estimated differences from the baseline to be smaller. But this only makes sense if the baseline level was chosen beforehand, or is otherwise meaningful as a default; otherwise it is effectively making the levels more similar to an arbitrarily chosen level.</p>
</div>
<div id="manually-building-the-model-matrix" class="section level3">
<h3>Manually building the model matrix</h3>
<p>To deal with the problems above, glmnetUtils by default will avoid using <code>model.frame</code>, instead building up the model matrix term-by-term. This avoids the memory cost of creating a <code>terms</code> object, and can be noticeably faster than the standard approach. It will also include one column in the model matrix for <em>all</em> levels in a factor; that is, no baseline level is assumed. In this situation, the coefficients represent differences from the overall mean response, and shrinking them to zero <em>is</em> meaningful (usually).</p>
<p>The main downside of not using <code>model.frame</code> is that the formula can only be relatively simple. At the moment, only straightforward formulas like <code>y ~ x1 + x2 + ... + x_p</code> are handled by the code, where the x’s are columns already present in the data. Interaction terms and computed expressions are not supported. Where possible, you should compute such expressions beforehand.</p>
</div>
<div id="speed-comparisons" class="section level3">
<h3>Speed comparisons</h3>
<p>To examine the speed impact of using <code>model.frame</code>, let’s do some simple comparisons of run times. We’ll generate sample datasets with 100, 1,000 and 10,000 predictors, and then run <code>glmnet</code> with both options for generating the model matrix.</p>
<!--- don't eval: speed up vignette build -->
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># generate sample (uncorrelated) data of a given size</span>
makeSampleData &lt;-<span class="st"> </span>function(N, P)
{
    X &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(N*P), <span class="dt">nrow=</span>N)
    <span class="kw">data.frame</span>(<span class="dt">y=</span><span class="kw">rnorm</span>(N), X)
}

<span class="co"># test for three sizes: 100/1000/10000 predictors</span>
df1 &lt;-<span class="st"> </span><span class="kw">makeSampleData</span>(<span class="dt">N=</span><span class="dv">1000</span>, <span class="dt">P=</span><span class="dv">100</span>)
df2 &lt;-<span class="st"> </span><span class="kw">makeSampleData</span>(<span class="dt">N=</span><span class="dv">1000</span>, <span class="dt">P=</span><span class="dv">1000</span>)
df3 &lt;-<span class="st"> </span><span class="kw">makeSampleData</span>(<span class="dt">N=</span><span class="dv">1000</span>, <span class="dt">P=</span><span class="dv">10000</span>)

<span class="kw">library</span>(microbenchmark)
res &lt;-<span class="st"> </span><span class="kw">microbenchmark</span>(
    <span class="kw">glmnet</span>(y ~<span class="st"> </span>., df1, <span class="dt">use.model.frame=</span><span class="ot">TRUE</span>), 
    <span class="kw">glmnet</span>(y ~<span class="st"> </span>., df1, <span class="dt">use.model.frame=</span><span class="ot">FALSE</span>), 
    <span class="kw">glmnet</span>(y ~<span class="st"> </span>., df2, <span class="dt">use.model.frame=</span><span class="ot">TRUE</span>), 
    <span class="kw">glmnet</span>(y ~<span class="st"> </span>., df2, <span class="dt">use.model.frame=</span><span class="ot">FALSE</span>), 
    <span class="kw">glmnet</span>(y ~<span class="st"> </span>., df3, <span class="dt">use.model.frame=</span><span class="ot">TRUE</span>), 
    <span class="kw">glmnet</span>(y ~<span class="st"> </span>., df3, <span class="dt">use.model.frame=</span><span class="ot">FALSE</span>),
    <span class="dt">times=</span><span class="dv">10</span> 
)
<span class="kw">print</span>(res, <span class="dt">unit=</span><span class="st">&quot;s&quot;</span>, <span class="dt">digits=</span><span class="dv">2</span>)</code></pre></div>
<!--- previous output -->
<pre><code>## Unit: seconds
##                                         expr   min    lq   mean median      uq    max neval
##   glmnet(y ~ ., df1, use.model.frame = TRUE) 0.020 0.021  0.022  0.021   0.022  0.025    10
##  glmnet(y ~ ., df1, use.model.frame = FALSE) 0.017 0.018  0.019  0.018   0.019  0.022    10
##   glmnet(y ~ ., df2, use.model.frame = TRUE) 3.844 4.132  4.508  4.358   4.759  5.504    10
##  glmnet(y ~ ., df2, use.model.frame = FALSE) 3.731 3.855  4.092  3.990   4.316  4.647    10
##   glmnet(y ~ ., df3, use.model.frame = TRUE) 8.587 8.678 10.268  9.484  10.373 17.714    10
##  glmnet(y ~ ., df3, use.model.frame = FALSE) 3.207 3.255  3.319  3.318   3.340  3.549    10</code></pre>
<p>From this, we can see that for datasets with up to 1,000 predictors, both methods are about as fast as each other. However, for 10,000 predictors (not uncommon these days), the <code>model.frame</code> method takes three times as long as building the model matrix term by term.</p>
<p>What happens if we take it up to 100,000 predictors? As seen below, the standard approach of using <code>model.frame</code> fails when R runs out of memory: the data frame itself is about 800MB in size, but trying to allocate the <code>terms</code> object requires more then 67GB. However, building the model matrix by term still works, and (on this machine) finishes in about two minutes.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df4 &lt;-<span class="st"> </span><span class="kw">makeSampleData</span>(<span class="dt">N=</span><span class="dv">1000</span>, <span class="dt">P=</span><span class="dv">100000</span>)

<span class="kw">glmnet</span>(y ~<span class="st"> </span>., df4, <span class="dt">use.model.frame=</span><span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## Warning in terms.formula(formula, data = data): Reached total allocation of
## 32666Mb: see help(memory.size)

## Error: cannot allocate vector of size 37.3 Gb</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">glmnet</span>(y ~<span class="st"> </span>., df4, <span class="dt">use.model.frame=</span><span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## Call:
## glmnet.formula(formula = y ~ ., data = df4, use.model.frame = FALSE)
## 
## Model fitting options:
##     Sparse model matrix: FALSE
##     Use model.frame: FALSE
##     Alpha: 1
##     Lambda summary:
##     Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
## 0.002393 0.006506 0.017680 0.032470 0.048080 0.130700</code></pre>
</div>
<div id="sparse-model-matrix" class="section level3">
<h3>Sparse model matrix</h3>
<p>As an option, glmnetUtils can also generate a <em>sparse</em> model matrix, using the <code>sparse.model.matrix</code> function provided in the Matrix package. This works exactly the same as a regular model matrix, but takes up significantly less memory if many of its entries are zero. A scenario where this is the case would be where many of the predictors are factors, each with a large number of levels. This can be combined with both of the previously mentioned options for generating model matrices.</p>
</div>
</div>
<div id="crossvalidation-for-alpha" class="section level2">
<h2>Crossvalidation for <span class="math inline">\(\alpha\)</span></h2>
<p>One piece missing from the standard glmnet package is a way of choosing <span class="math inline">\(\alpha\)</span>, the elastic net mixing parameter, similar to how <code>cv.glmnet</code> chooses <span class="math inline">\(\lambda\)</span>, the shrinkage parameter. To fix this, glmnetUtils provides the <code>cvAlpha.glmnet</code> function, which uses crossvalidation to examine the impact on the model of changing <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\lambda\)</span>. The interface is the same as for the other functions:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Leukemia dataset from Trevor Hastie's website:</span>
<span class="co"># http://web.stanford.edu/~hastie/glmnet/glmnetData/Leukemia.RData</span>
<span class="kw">load</span>(<span class="st">&quot;~/Leukemia.rdata&quot;</span>)
leuk &lt;-<span class="st"> </span><span class="kw">do.call</span>(data.frame, Leukemia)

leukMod &lt;-<span class="st"> </span><span class="kw">cvAlpha.glmnet</span>(y ~<span class="st"> </span>., <span class="dt">data=</span>leuk, <span class="dt">family=</span><span class="st">&quot;binomial&quot;</span>)
leukMod</code></pre></div>
<pre><code>## Call:
## cvAlpha.glmnet.formula(formula = y ~ ., data = leuk, family = &quot;binomial&quot;)
## 
## Model fitting options:
##     Sparse model matrix: FALSE
##     Use model.frame: FALSE
##     Alpha values: 0 0.001 0.008 0.027 0.064 0.125 0.216 0.343 0.512 0.729 1
##     Number of crossvalidation folds for lambda: 10</code></pre>
<p><code>cvAlpha.glmnet</code> uses the algorithm described in the help for <code>cv.glmnet</code>, which is to fix the distribution of observations across folds and then call <code>cv.glmnet</code> in a loop with different values of <span class="math inline">\(\alpha\)</span>. Optionally, you can parallelise this outer loop, by setting the <code>outerParallel</code> argument to a non-NULL value. Currently, glmnetUtils supports the following methods of parallelisation:</p>
<ul>
<li>Via <code>parLapply</code> in the parallel package. To use this, set <code>outerParallel</code> to a valid cluster object created by <code>makeCluster</code>.</li>
<li>Via <code>rxExec</code> as supplied by <a href="https://www.microsoft.com/en-au/cloud-platform/r-server">Microsoft R Server’s</a> RevoScaleR package. To use this, set <code>outerParallel</code> to a valid compute context created by <code>RxComputeContext</code>, or a character string specifying such a context.</li>
</ul>
<p>If the outer loop is run in parallel, <code>cvAlpha.glmnet</code> can check if the inner loop (over <span class="math inline">\(\lambda\)</span>) is also set to run in parallel, and disable this if it would lead to contention for cores.</p>
<p>Because crossvalidation is often a statistically noisy procedure, it doesn’t try to automatically choose <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\lambda\)</span> for you. Instead you can plot the output, to see how the results depend on the values of these parameters. Using this information, you can choose appropriate values for your data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(leukMod)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>In this case, we see that values of <span class="math inline">\(\alpha\)</span> close to <span class="math inline">\(1\)</span> tend to lead to better accuracy. The curves don’t have a well-defined minimum, but they do flatten out for lower values of <span class="math inline">\(\lambda\)</span>. As the <code>cv.glmnet</code> documentation recommends though, it’s a good idea to run <code>cvAlpha.glmnet</code> multiple times to reduce the impact of noise.</p>
<p>A <code>cvAlpha.glmnet</code> object contains a list of individual <code>cv.glmnet</code> objects, corresponding to the different <span class="math inline">\(\alpha\)</span> values tried. This lets you plot the crossvalidation results easily for a given <span class="math inline">\(\alpha\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(leukMod$modlist[[<span class="dv">10</span>]])  <span class="co"># alpha = 0.729</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
</div>
<div id="conclusion" class="section level2">
<h2>Conclusion</h2>
<p>The glmnetUtils package is a way to improve quality of life for users of glmnet. As with many R packages, it’s always under development; you can get the latest version from my <a href="https://github.com/Hong-Revo/glmnetUtils">GitHub repo</a>. If you find a bug, or if you want to suggest improvements to the package, please feel free to contact me at <a href="mailto:hongooi@microsoft.com">hongooi@microsoft.com</a>.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
